import {Component, OnInit, ElementRef, Injector, Input, SimpleChanges, ViewChild} from "@angular/core";
import {AbstractComponent} from "../../../common/component/abstract.component";
import {Tag} from "../tag-info/tag.value";
import {Image} from "../tag-info/image.value";
import {BuildHistoryService} from "../build-history/build-history.service";

declare var echarts: any;

@Component({
  selector: '[tag-security-vulnerability]',
  templateUrl: 'tag-security-vulnerability.component.html'
})
export class TagSecurityVulnerabilityComponent extends AbstractComponent implements OnInit {

  @ViewChild('searchInput')
  public searchInput: ElementRef;

  @Input()
  public security: Tag.Security;

  @Input()
  public layerList: Image.Layer[] = [];

  public sortProperty: string = 'score';
  public sortDirection: string = 'desc';

  public searchKey: string;

  public onlyFixed: boolean = false;

  public vulnerabilityList: Tag.Vulnerability[] = [];

  public colorCodes = ['#b7b9c2', '#b7b9c2', '#fcc419', '#fd7e14', '#f8523f'];

  public vulnerabilityCount: number = 0;
  public patchAvailableCount: number = 0;
  public highCount: number = 0;
  public mediumCount: number = 0;
  public lowCount: number = 0;
  public negiCount: number = 0;
  public unknownCount: number = 0;

  private chart: any;

  constructor(protected elementRef: ElementRef,
              protected injector: Injector,
              public buildHistoryService: BuildHistoryService) {

    super(elementRef, injector);
  }

  ngOnInit() {
  }

  public init(security: Tag.Security, layerList: Image.Layer[]) {
    this.security = security;
    this.layerList = layerList;
    this.searchKey = '';
    this.searchInput.nativeElement.value = '';
    this.onlyFixed = false;

    this.getVulnerabilityList();
  }

  /**
   * 정렬
   * @param colName
   * @param sort
   */
  public sortClick(property: string) {
    if (this.sortProperty == property) {
      this.sortDirection = this.sortDirection == 'desc' ? 'asc' : 'desc';
    } else {
      this.sortDirection = 'desc';
    }
    this.sortProperty = property;
  }

  /**
   * Show Fixable Change
   */
  public changeCheck() {
    // this.onlyFixed = !this.onlyFixed;
    this.getVulnerabilityList(false);
  }

  public clearSearchClick() {
    this.searchKey = '';
  }

  /**
   * 링크 클릭
   * @param v
   */
  public linkClick(v: Tag.Vulnerability) {
    window.open(v.Link);
  }

  /**
   * 취약점 목록
   */
  public getVulnerabilityList(createChart: boolean = true) {
    this.vulnerabilityCount = 0;
    this.patchAvailableCount = 0;
    this.highCount = 0;
    this.mediumCount = 0;
    this.lowCount = 0;
    this.negiCount = 0;
    this.unknownCount = 0;

    if (createChart && this.chart) {
      this.chart.dispose();
      this.chart = null;
    }

    let list = [];
    if (this.security.status != 'queued') {
      this.security.data.Layer.Features.forEach(value => {
        if (value.Vulnerabilities && value.Vulnerabilities.length) {
          value.Vulnerabilities.forEach(v => {
            this.vulnerabilityCount++;

            if (v.Severity == Tag.VulnerabilityType.High) {
              v.score = 4;
              this.highCount++;
            } else if (v.Severity == Tag.VulnerabilityType.Medium) {
              v.score = 3;
              this.mediumCount++;
            } else if (v.Severity == Tag.VulnerabilityType.Low) {
              v.score = 2;
              this.lowCount++;
            } else if (v.Severity == Tag.VulnerabilityType.Negligible) {
              v.score = 1;
              this.negiCount++;
            } else if (v.Severity == Tag.VulnerabilityType.Unknown) {
              v.score = 0;
              this.unknownCount++;
            } else {
              v.score = -1;
            }

            if (v.FixedBy) {
              this.patchAvailableCount++;
            }

            if ((this.onlyFixed && v.FixedBy) || !this.onlyFixed) {
              v.packageName = value.Name;
              v.currentVersion = value.Version;
              v.expand = false;
              v.layer = this.getLayerByImageId(value.AddedBy);
              list.push(v);
            }
          });
        }
      });

      if (createChart) {
        this.createChart();
      }
    }
    this.vulnerabilityList = list;
  }

  /**
   * layer 정보 조회
   * @param imageId
   * @returns {Image.Layer}
   */
  private getLayerByImageId(imageId: string) {
    let layer = new Image.Layer();
    imageId = imageId.split('.')[0];

    this.layerList.forEach(value => {
      if (value.id == imageId) {
        layer = value;
      }
    });

    return layer;
  }

  /**
   * chart 생성
   */
  private createChart() {

    if (!this.chart) {
      var dom = document.getElementById('chartVulnerabilities');
      this.chart = echarts.init(dom);
    }

    let data = [];
    if (this.highCount) {
      data.push({name: Tag.VulnerabilityType.High, value: this.highCount, itemStyle: {
        color: this.colorCodes[4]
      }});
    }

    if (this.mediumCount) {
      data.push({name: Tag.VulnerabilityType.Medium, value: this.mediumCount, itemStyle: {
        color: this.colorCodes[3]
      }});
    }

    if (this.lowCount) {
      data.push({name: Tag.VulnerabilityType.Low, value: this.lowCount, itemStyle: {
        color: this.colorCodes[2]
      }});
    }

    if (this.negiCount) {
      data.push({name: Tag.VulnerabilityType.Negligible, value: this.negiCount, itemStyle: {
        color: this.colorCodes[1]
      }});
    }

    if (this.unknownCount) {
      data.push({name: Tag.VulnerabilityType.Unknown, value: this.unknownCount, itemStyle: {
        color: this.colorCodes[0]
      }});
    }

    if (!this.vulnerabilityCount) {
      data.push({name: 'None', value: 1, itemStyle: {
        color: '#40c057'
      }});
    }

    let series = [
      {
        type:'pie',
        radius: ['60%', '100%'],
        avoidLabelOverlap: false,
        hoverAnimation: false,
        label: {
          normal: {
            show: true,
            formatter: (params) => {
              return Math.round(params.percent) + '%';
            },
            position: 'inside'
          }
        },
        labelLine: {
          normal: {
            show: false
          }
        },
        data: data
      }
    ];

    let option = {
      tooltip: {
        trigger: 'item',
        formatter: (params) => {
          return `${params.name}<br/>${params.value} (${Math.round(params.percent)}%)`;
        },
      },
      series: series
    };

    this.chart.setOption(option, true);
  }

}
